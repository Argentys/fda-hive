/*
 *  ::718604!
 * 
 * Copyright(C) November 20, 2014 U.S. Food and Drug Administration
 * Authors: Dr. Vahan Simonyan (1), Dr. Raja Mazumder (2), et al
 * Affiliation: Food and Drug Administration (1), George Washington University (2)
 * 
 * All rights Reserved.
 * 
 * The MIT License (MIT)
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 Copyright (c) 2015 Dr. Vahan Simonyan vahansim@gmail.com
 This software is protected by viVI. Unauthorized use, duplication,
 reverse engineering, any form of redistribution, use in part or as
 a whole, other than by prior, express, written and signed agreement
 is subject to penalties in the form of removal from this physical reality.
 If you have received this file in error, or you had a Chimp with infinite time
 at hands to accidentally type this alpha-mememtic sequence on a keyboard,
 or if this file has been generated by quantum fluctuations - please notify
 copyright holder and destroy this and any other copies.
 All rights reserved except the right to be imaginative.
 */


/*

    public:
     
    // STYLE
        className : "JSON_TREE" // base for all classes used by this control
        hideEmpty : undefined // flag hiding the empty nodes with no children 
        showDepth: undefined // flag forcing to show up to the depth of the nodes
        autoExpand: 2 // automatical expansion of node to this depth
        renderStartNodePath : "root" // path to the node from which rendering starts 
        
    // PAGINATOR 
        pagingSizeSelect: 30 // paginator current selection
        pagingSizes: [20,50,100,100,all] // paginator alternatives
    
    // CALLBACKS
        onRefreshDoneCallback // ???? TODO : do I really need this ? vjDataView already does provide this functgionality
    
    
    // NODE ELEMENTS
        node : { 
            __sub: // elements identifier in the db
            __dim // total number of children elements in db
            __start // start of the current page  
            __cnt // count of elements  satisfying current search and page criteria
            __total // total number of elements including children's hierarchy 
            __cntChildren // number of children loaded into a particular page of the node's children 
              
            __invisible: undefined //  hidden nodes 
            __depth // the depth of current node 
            __collapsed  // the node is collapsed
            __cntChildren // actual number of childred loaded currently 
            __path // path to the element
            __pagingSizeSelect // the size of the page for current node's children 
        } 

     
     v_nodeReload : root // path to the node which is being updated
     v_nodeAppendMode: true  // updated node is reseting or appending   
     
     v_prvMouseOverNode
     
      


    

 */

function vjIonHCView ( viewer )
{
    loadCSS("css/hivesys.css");
    vjDataViewViewer.call(this,viewer); // inherit default behaviours of the DataViewer
    
    this.onRefreshDoneCallback = viewer.onRefreshDoneCallback;
    
    setDefaults( this,{
        className : "JSON_TREE",
        lastSearch: "",
        pagingSizes: [20,50,100,1000,"all"],
        pagingSizeSelect:20,
        icons: {empty: 'img/tree-white_minus_slim_dotted.png', leaf : 'img/recItem.gif' , size : 16 },
        autoExpand : 2
    }) ;

    this.searchDic={};

    
    this.composerFunction=function( viewer , content )
    {
        if(this.debug)alert(content);

        // parse the input data 
        var node;
        //node=JSON.parse(content);
        eval("node="+content+";");
        if(!node.__sub) {
            alert("no elements");
            return ;
        }
        
        // initiate creation of root node if this node has not been created yet 
        if(!this.root) {
            //for ( f in node ) {if(f.indexOf("__")==0)continue;node=node[f];break;}
            this.root=node;
            this.root.__depth=0;
            this.root.__name="$root";
            this.v_nodeReload=this.root;
            this.root.__path="";
            this.refresh();
        }
        else { // otherwise this is an update of existing node 
            
            // find the node which is being updated   
            var attach=findJsonField(this.root, this.v_nodeReload,true);    
            if(!attach)attach={ parent: this , field : "root" , node: this.root } ; // if cannot find - that node is the root node
            
            // attachment of the element into the existing treee 
            if(this.v_nodeAppendMode) { // in an update mode 
                for ( f in node )  {
                    if(f=="__cnt")attach.node[f]+=node[f]; // we increment __cnt which shows actual number of elements loaded
                    else attach.node[f]=node[f]; // and we maintain all the previous fields 
                }
            }else { // in a node replace content mode (not an update) 
                
                if(node.__sub!="$root") {  // since we are updating not root - we have to remake its path from its attachment parent 
                    node.__path=attach.parent.__path ? attach.parent.__path+"."+attach.field : attach.field ;
                    node.__name=attach.field; // we retain its name 
                    node.__depth=attach.parent[attach.field].depth; // and recover its depth 
                }else {
                    node.__path=""; // for the root node - we set path to empty
                }
                
                // recovery of other visualization aspects for this node : collapse , paging, etc  
                if(attach.node.__pagingSizeSelect)
                    node.__pagingSizeSelect=attach.parent[attach.field].__pagingSizeSelect;
                if(!node.__pagingSizeSelect)
                    node.__pagingSizeSelect=this.pagingSizes[0];                
                node.__collapsed=attach.parent[attach.field].__collapsed;
                
                // recompute actual count of children loaded here 
                if(node.__cntChildren==undefined) {
                    node.__cntChildren=0;
                    for( var f in node) { 
                        if(f.indexOf("__")==0)continue; // skip all service elements
                        ++node.__cntChildren;
                    }
                }
                // actual attachment of the node 
                attach.parent[attach.field]=node;
            }

            // refresh the element which is being updated and put it into the DIV 
            var t=this.outputNodeChildren(attach.parent[attach.field],-1);
            if (node.__path == "root"){ //if the entire DS for the entire tree was reloaded, we need to attach it to the very top, not children
                gObject(this.div.id).children[0].innerHTML=t;
            }else{
                gObject((this.div.id+node.__path)+"-children").innerHTML=t;
            }
            // clean mouse Over Status
            this.v_prvMouseOverNode=undefined;
            
            // reset the node control text and node information text to the node which has been updated
            this.doNodeControlText(node);
            this.doNodeInfoText(node);
        }
        
        // fix array statistic info
        this.iterateJsonFixArr(this.root);
        
        // signify that we are out of node refresh mode 
        this.v_nodeReload=null;
        
        // call back to declare the node refresh has been completed
        if (this.onRefreshDoneCallback)
            this.onRefreshDoneCallback (node);
    };

    // this function walks down the json structure and fixes ion style node service statistics information for arrays
    this.iterateJsonFixArr=function(node) 
    {
        for( var f in node) { 
            if( node[f] instanceof Object ) {
                if(f.indexOf("__[]")==0){
                    var cn=node[f.substring(4)];

                    cn.__dim=node[f].__dim;
                    cn.__start=node[f].__start;
                    cn.__cnt=node[f].__cnt;
                    cn.__tot=node[f].__tot;
                }
                
                this.iterateJsonFixArr(node[f]);
            }
        }
    }
    
    
    
    // this function refreshes the entire json
    this.refresh=function(node)
    {
        // allocate the node from which down we sstart rendering 
        if( !node ) { 
            if(this.renderStartNodePath)  { 
                node=findJsonField(start, this.renderStartNodePath , true);
                if(!node)node=this.root;else node=node.node;
            }
            else 
                node = this.root;
        }

        // prefix to the json representation
        var t="";
        if(this.prefixHTML && node==this.root )
            t+=this.prefixHTML;
        
        t+="<ul class='"+this.className+"'><li class='"+this.className+"_last' ";
        t+=" onClick='vjObjEvent(\"onCollapseNode\",\""+this.objCls+"\",\""+(node.__path)+"\");' ";
        t+=" onMouseOver='vjObjEvent(\"onMouseOver\",\""+this.objCls+"\",\""+(node.__path)+"\",1);' ";
        t+=">"+this.outputNode( node ,-1)+"</li></ul>";
        
        // postfixc to the json representation
        if (this.appendHTML && node==this.root ) 
            t += this.appendHTML;

        gObject((this.div.id + this.root.__path)).innerHTML=t;
    };

    
    // finds the node by its path
    this.findeNodeByPath=function(start, nodePath )
    {
        var node  = findJsonField(start, nodePath, true);
        if(!node)return this.root;
        else return node.node;
    }
    
    // _/_/_/_/_/_/_/_/_/_/_/
    // _/
    // _/ tree manipulations
    // _/
    // _/_/_/_/_/_/_/_/_/_/_/
    this.onSearchChange=function(cls,nodePath)
    {
        this.grabMouse=false;
        if(this.v_nodeReload)return 1;
        var node  = this.findeNodeByPath(this.root, nodePath, true);
        this.v_nodeReload=nodePath;
        
        var o = gObject((this.div.id+node.__path)+"-search");if(!o)return 0;
        this.lastSearch=o.value;
        var url=this.getData(0).url;
        if(o.value[0]==':') {
            url=urlExchangeParameter(url, "brInto", escape(o.value.substring(1)));
            url=urlExchangeParameter(url, "brSearch", "-" );
        } else { 
            url=urlExchangeParameter(url, "brSearch", escape(o.value));
            url=urlExchangeParameter(url, "brInto", "-" );
        }
        url=urlExchangeParameter(url, "sub", node.__sub);
        this.searchDic[node.__path]=o.value;
        this.getData(0).reload(url,true);
        return 1;
    }
    
    this.onPage=function(cls,nodePath,direction)
    {
        this.grabMouse=false;
        if(this.v_nodeReload)return 1;
        var node  = this.findeNodeByPath(this.root, nodePath, true);
        
        this.v_nodeReload=nodePath;
        var url=this.getData(0).url;
        var pgCnt=node.__pagingSizeSelect ? node.__pagingSizeSelect : this.pagingSizeSelect ;
        
        if(direction==1) { 
            var brStart=node.__start+node.__cnt;if(brStart>=node.__dim)brStart=node.__dim-node.__cnt;
            url=urlExchangeParameter(url, "brStart", brStart);
            url=urlExchangeParameter(url, "sub", node.__sub);
//            url=urlExchangeParameter(url, "brCnt", pgCnt );            
        }
        else if(direction==-1) {
            var brStart=node.__start-node.__cnt;if(brStart<0)brStart=0;
            url=urlExchangeParameter(url, "brStart", brStart);
            url=urlExchangeParameter(url, "sub", node.__sub);
            //url=urlExchangeParameter(url, "brCnt", pgCnt );
        }
        else if(direction==0) { 
            //url=urlExchangeParameter(url, "brCnt", 0 );
            //if(gKeyShift)
            //    url=urlExchangeParameter(url, "brCntAfter", 0);
            pgCnt=0;
            url=urlExchangeParameter(url, "brStart", 0);
            url=urlExchangeParameter(url, "sub", node.__sub);
        }else { 
            url=urlExchangeParameter(url, "sub", node.__sub);
            //url=urlExchangeParameter(url, "brCnt", pgCnt );
        }
        url=urlExchangeParameter(url, "brCnt", pgCnt );
        if(gKeyShift)
            url=urlExchangeParameter(url, "brCntAfter", pgCnt);    
        
             //url=urlExchangeParameter(url, "sub", node.__sub);
        this.getData(0).reload(url,true);
        return 1;
    }
    
    this.onPagingSizeSelect=function(cls, nodePath)
    {
        this.grabMouse=false;
        var node  = this.findeNodeByPath(this.root, nodePath, true);
        node.__pagingSizeSelect=event.srcElement.value;
        //this.nodeControlText(node);
        this.onPage(cls,nodePath,node.__pagingSizeSelect);
    }

    this.onCollapseNode=function(cls,nodePath)
    {
        this.grabMouse=false;  
        var node  = this.findeNodeByPath(this.root, nodePath, true);
        
        var o = gObject((this.div.id+node.__path)+"-children");
                        
        var ochld = gObject((this.div.id+node.__path)+"-children-info");
        if(o) { 
            if( !node.__collapsed ) {
                node.__collapsed=o.className;
                o.className="sectHid";
                if(ochld)ochld.className=node.__collapsed;
            } else {
                o.className=node.__collapsed;
                node.__collapsed=false;
                if(ochld)ochld.className="sectHid";
            }
        }
        this.v_prvMouseOverNode=undefined;
        this.doNodeControlText(node);
        
        if (this.clickNodeCallback) this.clickNodeCallback( this, nodePath);
        
        return true;
    }
    
    
    this.onMouseOver=function(cls,nodePath,what)
    {
        if(this.v_paginmode)return 1;
        if(this.grabMouse)return 1;
        var node  = this.findeNodeByPath(this.root, nodePath, true);
        
        //console.log(nodePath + " " + node );
        if(this.v_prvMouseOverNode==node.__path)return 1;
        this.doNodeControlText(node);
                    
        return 1;
    }
    
    this.onClickInput=function(cls,nodePath,what){this.grabMouse=true;}
    this.doReleaseMouse=function(cls,nodePath,what){this.grabMouse=false;}
    gOnDocumentClickCallbacks+="vjObjEvent(\"doReleaseMouse\",\""+this.objCls+"\");";
    
    // _/_/_/_/_/_/_/_/_/_/_/
    // _/
    // _/ operations
    // _/
    // _/_/_/_/_/_/_/_/_/_/_/

    this.doNodeControlText=function(node)
    {
        var o = gObject((this.div.id+node.__path)+"-children-page");if(!o)return 1;
        
        o.innerHTML=this.nodeControlText(node);
        
        if( !(this.v_prvMouseOverNode===undefined) && gObject((this.div.id+this.v_prvMouseOverNode)+"-children-page")) {
            //gObject(this.div.id+this.v_prvMouseOverNode.__path+"-children-page").innerHTML="";
            gObject((this.div.id+this.v_prvMouseOverNode)+"-children-page").innerHTML="";
        }
        this.v_prvMouseOverNode=node.__path; 
            
        return 1;
        
    }

    this.doNodeInfoText=function(node)
    {
        var o = gObject((this.div.id+node.__path)+"-children-info");if(!o)return 1;
        
        o.innerHTML=this.nodeInfoText(node);
        return 1;
        
    }
    
    this.nameManipulate=function(node,name)
    {
        return (name[0]=='_') ? "<small>&equiv;</small>"+name.substring(1) : name;
    }
    
    
    // _/_/_/_/_/_/_/_/_/_/_/
    // _/
    // _/ tree construction
    // _/
    // _/_/_/_/_/_/_/_/_/_/_/


    this.outputNode=function( node , v_maxLevel )
    {

        // make decision if this nodes and the ones under it should be shown or not 
        if( ( node.__invisible ) ||
            ( this.hideEmpty && !node.__cntChildren ) || 
            ( this.showDepth && node.__nodeDepth && this.showDepth<node.__nodeDepth )
            ) return "";

        // count children as all fields which do not start on underscore 
        if(node.__cntChildren==undefined) {
            node.__cntChildren=0;
            for( var f in node) { if(f.indexOf("__")==0)continue;
                ++node.__cntChildren;
            }
        }
        // make decision about expansion status of this node and the autoExpand setting 
        if(this.autoExpand>0 && node.__depth>this.autoExpand) {  
            node.__collapsed=this.className;
        }
        
        var t="";
        //t+=this.formDataValue(node.__name, node.__type, node, null);
        //if(t[0]=='_')t="&#x2736;"+t.substring(1);
        t+=this.nameManipulate(node,node.__name);
        t+="&nbsp;";
        t+="<span class='";
        t+=(node.__collapsed) ? this.className : "sectHid";
        t+="' id='"+(this.div.id+node.__path)+"-children-info'>"+this.nodeInfoText(node)+"</span>";
        //if(node.__cntChildren<node.__dim)  {
        if(node.__cntChildren)  {
            t+="&nbsp;<span id='"+(this.div.id+node.__path)+"-children-page'>";
            if(node.__path==this.v_nodeReload)t+=this.nodeControlText(node);
            t+="</span>";
            
            t+="<ul class='"
            
            if(node.__collapsed) { 
                t+="sectHid";
            }else 
                t+=this.className;
            t+="' ";
            t+="id='"+(this.div.id+node.__path)+"-children'";
            t+=" >";

            if(v_maxLevel)
                t+=this.outputNodeChildren( node , v_maxLevel  );            
            t+="</ul>";
        }
        
        
        return t;
    };

    this.outputNodeChildren=function( node , v_maxLevel  )
    {
        var icnt=0;
        var t="";
        for( var f in node ) {if(f.indexOf("__")==0)continue;
            var prefix= (node.__path) ? (node.__path+".") : "" ;
            
            t+="<li ";
            t+=" id='"+(this.div.id+node.__path+f)+"' ";
            if(icnt==node.__cntChildren-1){
                t+="class='"+this.className+"_last' ";
            }
            t+=" onClick='vjObjEvent(\"onCollapseNode\",\""+this.objCls+"\",\""+(prefix+f)+"\");' ";
            t+=" onMouseOver='vjObjEvent(\"onMouseOver\",\""+this.objCls+"\",\""+(prefix+f)+"\",1);' ";
            t+=">";
            
            var cn=node[f];
            
            if( typeof(cn)=="object" && f.indexOf("__[]")!=0 ){
                cn.__depth=node.__depth+1;
                cn.__name=f;
                cn.__path=prefix+cn.__name;
                if(v_maxLevel)
                    t+=this.outputNode ( cn , v_maxLevel==-1 ? v_maxLevel : v_maxLevel-1 ) ;
            } else {
                //t+= (f[0]=='_') ? "&#x2736;"+f.substring(1) : f ;
                t+=this.nameManipulate(node,f);
                t+="&nbsp;:&nbsp;";
                if(f.indexOf("descr")==0 || f.indexOf("comment")==0)t+="<textarea onClick='return 0;' rows=2 class='"+this.className+"-input' type='text' cols=40 />"+(cn)+"</textarea>";
                else t+="<input onClick='return 0;' class='"+this.className+"-input' type='text' size=40 value='"+(cn)+"' />";
                
                
            }
            
            //t+="</span>";
            t+="</li>";
            ++icnt;
        }
        return t;
    }
    
    

    this.nodeControlText=function(node)
    {
        var t="";
        //if(ctlnode)
        if( node instanceof Array  ) {
            //var rpl = this.findeNodeByPath(this.root, nodePath, true);
            //this.findeNodeByPath
            //if(rpl)node=rpl;
        }
            // node=node["__[]"+f];
        if(node.__cntChildren)t+="<small>"+(node.__collapsed ? "&#x21e9;" : "&#x21ea;")+"</small>";
        t+="<small><span onChange='javascript:vjObjEvent(\"onSearchChange\",\""+this.objCls+"\",\""+(node.__path)+"\");' >?</span></small>"
        if(node.__collapsed)
            return t;
        
        if(node.__start)t+="<span class='"+this.className+"' onClick='javascript:vjObjEvent(\"onPage\",\""+this.objCls+"\",\""+(node.__path)+"\",-1);' >&#x25C4;</span>";
        else t+="<span class='"+this.className+"' onClick='return eventStop(event);' style='color:white' >&#x25C4;</span>";
        if(node.__cnt!=1)t+="<small><small>&nbsp;"+(node.__start+1)+"-"+(+node.__start+node.__cntChildren)+" of "+node.__dim+"</small></small>&nbsp;";
        if(node.__cnt<node.__dim){
            if(this.pagingSizes && this.pagingSizes.length){
                t+="<small><select class='"+this.className+"-control' style='width:48px' "+
                    "onChange='javascript:vjObjEvent(\"onPagingSizeSelect\",\""+this.objCls+"\",\""+(node.__path)+"\",-1);' "+
                    "onClick='if(event.stopPropagation)event.stopPropagation();event.cancelBubble=true;return 0;' "+
                    " >";
                for( var i=0; i<this.pagingSizes.length; ++i ){
                    t+="<option value='"+this.pagingSizes[i]+"' ";
                    if(node.__pagingSizeSelect==this.pagingSizes[i])t+=" selected ";
                    else if(this.pagingSizeSelect==this.pagingSizes[i])t+=" selected ";
                    t+=" >";
                    t+=this.pagingSizes[i];
                    t+="</option>";
                }
                t+="</select></small>";
            }

        }
        if(node.__start + node.__cnt <node.__dim)t+="<span class='"+this.className+"' onClick='javascript:vjObjEvent(\"onPage\",\""+this.objCls+"\",\""+(node.__path)+"\",+1);' >&#x25BA;</span>";
        t+="&nbsp;<input class='"+this.className+"-control' id='"+(this.div.id+node.__path)+"-search'  "+
            "onChange='javascript:vjObjEvent(\"onSearchChange\",\""+this.objCls+"\",\""+(node.__path)+"\");' "+
            "onClick='javascript:vjObjEvent(\"onClickInput\",\""+this.objCls+"\",\""+(node.__path)+"\");if(event.stopPropagation){event.stopPropagation();}event.cancelBubble=true;return 0;' "+
            //"onClick='if(event.stopPropagation){event.stopPropagation();}event.cancelBubble=true;return 0;' "+
            "class='"+this.className+"-search' type='text' size=40 value='"+(this.searchDic[node.__path] ? this.searchDic[node.__path] : this.lastSearch)+"' />&nbsp;";
    
        
        //if(node.__cnt<node.__dim){
        //    t+="<span class='"+this.className+"' onClick='javascript:vjObjEvent(\"onPage\",\""+this.objCls+"\",\""+(node.__path)+"\",0);' >&#x263C;</span>";
        //}
        return t;
    }

    this.nodeInfoText=function(node)
    {
        //return t="<small><small>:&nbsp;"+node.__cntChildren+"/"+node.__dim+"</small></small>";
        return t="";//<small><small>:&nbsp;"+(node.__start+1)+"-"+(+node.__start+node.__cntChildren)+" of "+node.__dim+"</small></small>";
    }    

}

//# sourceURL = getBaseUrl() + "/js/vjIonHC.js"